filelist=("$@")
infile="${filelist[0]}"

if [[ -z ${infile} ]];then
	echo
	echo "You must supply a filename or list of files (wildcards ok)"
	echo
	echo "Usage: marcmerge [filelist]"
	echo 
	exit
fi


echo "Starting processing. Please wait"

read -r -d '' awkscript << "ENDOFAWK"
#!/usr/bin/awk -f 

BEGIN { 
	subfield_regex=SFS"."
	subb=SFS"b"
	subp=SFS"p"
	subfielda=".*"SFS"a([^"SFS"]*).*"
	subfieldb=".*"SFS"b([^"SFS"]*).*"
	subfieldc=".*"SFS"c([^"SFS"]*).*"
	subfieldf=".*"SFS"f([^"SFS"]*).*"
	subfieldn=".*"SFS"n([^"SFS"]*).*"
	subfieldp=".*"SFS"p([^"SFS"]*).*"
	validdate="^[^0-9]*([0-9][0-9][0-9][0-9])[^0-9].*"


      if (length("Ð°") != 2) {
                badawk = 1
                printf("Your version of awk does not support  -- you need a version that supports the -b switch\\n")
                exit
      }
}


function extractsubfields() {
	# still needs to be written
	fixedfield = substr(record_content, starting_pos + 1, field_length - 1)
}

function firstxdigits(getstring, numchars) {
	delete temp_arr
	longest_match = ""

	match(getstring, "[0-9]+", temp_arr)
	lengthtemp = length(temp_arr)

	for (i = 0; i <= lengthtemp - 1; i++) {
		current_match = temp_arr[i]

		if (length(current_match) > length(longest_match)) {
			longest_match = current_match
			if (length(current_match) >= numchars) { break } 
		}
	}
	return longest_match
}

function getfixedfield() {
	fixedfield = substr(record_content, starting_pos + 1, field_length - 1)
}

function getvarfield() {
	varfield = substr(record_content, starting_pos + 3, field_length - 4)
}

function extract_tags() {
	for (d_iter=1; d_iter<=directory_length; d_iter=d_iter+12) {
		marc_tag = substr(directory, d_iter, 3)
		field_length = substr(directory, d_iter + 3, 4) + 0
		starting_pos = substr(directory, d_iter + 7, 5) + 0

		if (marc_tag == "008") {
			gooddate = 0
			getfixedfield()
			tag008 = fixedfield

			date008 = substr(tag008, 12, 4)

			if (date008 ~ /[12][0-9][0-9][0-9]/) {
				gooddate = 1
				pubdate = date008
			}

			if (gooddate == 0){ 
				date008 = substr(tag008, 8, 4)
				if (date008 ~ /[12][0-9][0-9][0-9]/) {
					gooddate = 1
					pubdate = date008
				}
			} 

		}

		if (marc_tag == "086") {
			getvarfield()
			tag086 = varfield
			tag086 = tolower(gensub(subfielda, "\\\1", "1", tag086))
			gsub(/[^[:alnum:]]/, "", tag086)
		}
		if (marc_tag == "100" || marc_tag == "110" || marc_tag == "111" || marc_tag == "130") {
			getvarfield()
			tagme = varfield
			tagme = tolower(gensub(subfielda, "\\\1", "1", tagme))
			gsub(/[^[:alnum:]]/, "", tagme)
		}
		if (marc_tag == "245") {
			getvarfield()
			tag245 = varfield
			tag245a = gensub(subfielda, "\\\1", "1", tag245) 
			
			if (tag245 ~ subb) { tag245b = gensub(subfieldb, "\\\1", "1", tag245) }
			if (tag245 ~ subp) { tag245p = gensub(subfieldp, "\\\1", "1", tag245) }
			tag245 = tolower(tag245a""tag245b""tag245p)
			gsub(/[^[:alnum:]]/, "", tag245)
			tag245 = pad(tag245, 70)
		}
		if (marc_tag == "250") {
			getvarfield()
			tag250 = varfield
			tag250 = substr(tolower(gensub(subfielda, "\\\1", "1", tag250)), 1, 3)
			sub(/fir/, "1", tag250)
			sub(/sec/, "2", tag250)
			sub(/th[ir]/, "3", tag250)
			sub(/fou/, "4", tag250)
			sub(/fi[vf]/, "5", tag250)
			sub(/six/, "6", tag250)
			sub(/sev/, "7", tag250)
			sub(/eig/, "8", tag250)
			sub(/nin/, "9", tag250)
			sub(/10/, "10", tag250)
			gsub(/[^[:alnum:]]/, "", tag250)
		}
		if (marc_tag == "260") {
			if (gooddate == 0) {
				getvarfield()
				tag260 = varfield
				tag260a = gensub(subfielda, "\\\1", "1", tag260)
				tag260b = gensub(subfieldb, "\\\1", "1", tag260)
				date260 = gensub(validdate, "\\\1", "1", tag260b)

				if (date260 ~ /[0-9][0-9][0-9][0-9]/) { gooddate = 2 }
			}
		}
		if (marc_tag == "264") {
			if (gooddate != 1 ) {
				getvarfield()
				tag264 = varfield
				tag264 = gensub(subfieldb, "\\\1", "1", tag264)
				date264 = gensub(validdate, "\\\1", "1", date264)

				if (date264 ~ /[0-9][0-9][0-9][0-9]/) { pubdate = date264 }
			} 
		}
		if (marc_tag == "300") {
			getvarfield()
			tag300 = varfield
			tag300 = tolower(gensub(subfielda, "\\\1", "1", tag300))
			tag300 = firstxdigits(tag300, 4)
			tag300 = pad(tag300, 4)
		}
	}
}

function pad(checkstring, neededlength) {
	checkstring = substr(checkstring, 1, neededlength)
    
	if (length(checkstring) < neededlength) {
		num_underscores = neededlength - length(checkstring);
		for (i = 0; i < num_underscores; i++) { checkstring = checkstring"_" }
	}
	return checkstring
}

{

leader=substr($0,1,24)
baseaddress=substr(leader,13, 5) + 0
directory=substr($0,25, baseaddress - 25)
directory_length=length(directory) 
directory_check=(directory_length % 12)
record_content=substr($0, baseaddress + 1)
bib_mattype=substr(leader, 7, 1)
holdings_type=substr(leader, 8, 1)

tag008=tag086i=tag245=tag245a=tag245b=tag245p=tag250=tag260=tag264=tagme=date260=date264=tag300=""
pubdate="0000"

if (directory_check == 0) {
	record_type = substr(leader, 7, 1)
	extract_tags()
}

if (NR % 10000 == 0){ printf "Records processed: "NR"\r" }

}
END { print NR" MARC records have been processed and sent to "OUTFILE }

ENDOFAWK

echo -e "${awkscript}" > tmp_checkmarc
chmod 700 tmp_checkmarc

awk -v RS=$'\x1d' -v ORS="\n" -v SFS=$'\x1f' -v FS=$'\x1e' -v OFS="\t" -v OUTFILE="${outfile}" -b -f tmp_checkmarc "${infile}"
echo

rm -f tmp_checkmarc
