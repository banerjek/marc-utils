# sirsi was inadvertantly modified to accommodate NALIS -- must be modified

knownsystems=("absysnet" "aleph" "destiny" "eos" "hylib" "janium" "koha" "lc2" "opals" "sierra" "sirsi" "softlink" "tlc" "tinycat" "virtua" "wms")

if [[ -z $2 ]];then
	echo "Usage: marc-itemextract [filename] [systemtype] "
	echo 
	echo "001 is automatically stored and output."  
	echo "Items are expected to be one item per MARC tag"
	echo
	echo "The following systems are known"
	echo  ${knownsystems[@]}
	exit
else
	infile="${1}"
	system="${2}"
	tags=()
	labels=()

	fileroot=$(echo "${infile}" | sed 's/\.....\?$//')
	outfile="${fileroot}.tsv"
	rm -f ${outfile}
fi

foundsystem=0

for checksystem in "${knownsystems[@]}";do
	if [[ ${system} == $checksystem ]];then foundsystem=1;fi
done


if [[ ${foundsystem} -eq 0 ]];then
	echo "You must specify a known system from the following"
	echo  ${knownsystems[@]}
	exit
fi

## be sure to map call number and location to holdid

if [[ ${system} == "absysnet" ]];then
	identifier="001"
	item_field="995s"
	item_call_subfield="r5a"
	location_subfield="h"
	taglabelmap="a:copy d:loantype e:subject f:barcode k:call# s:mattype u:location"
fi

if [[ ${system} == "aleph" ]];then
	identifier="001"
	item_field="LKRa"
	location_subfield="l"
	taglabelmap="a:link_type b:sysno l:library r:marc_tag s:order_sequence v:volume y:year i:enumeration p:part m:note1 n:note2" 
fi

if [[ ${system} == "destiny" ]];then
	special[1]="852"

	identifier="001"
	item_field="852p"
	item_call_subfield="h"
	location_subfield="b"
	taglabelmap="p:barcode h:call# u:itype b:location j:volume t:copy z:note r:catdate n:staffnote f:collectionnote 9:price"
fi

if [[ ${system} == "eos" ]];then
	identifier="001"
	item_field="949z"
	item_call_subfield="a"
	location_subfield="h"
	taglabelmap="z:barcode a:call# o:itype b:location"
fi

if [[ ${system} == "hylib" ]];then
	identifier="001"
	item_field="095b"
	item_call_subfield="d"
	location_subfield="h"
	taglabelmap="c:barcode d:call# p:itype b:location m:status z:loantype k:copy y:volume n:note m:code1"
fi

if [[ ${system} == "janium" ]];then
	identifier="001"
	item_field="999"
	item_call_subfield="a"
	location_subfield="l"
	taglabelmap="m:library l:location r:call i:barcode2 m:barcode t:mattype u:staff_note v:volume x:staff_note2 z:staff_note3 0:copy r:loan_type f:note g:note_inventory k:cat_date"
fi

if [[ ${system} == "koha" ]];then
	identifier="001"
	item_field="952p"
	item_call_subfield="o"
	location_subfield="b"
	taglabelmap="p:barcode 8:call#prefix o:call# t:copy y:mattype g:price z:public_note d:inventory_date b:location 7:loan_type"
fi

if [[ ${system} == "lc2" ]];then
	identifier="001"
	item_field="949z"
	item_call_subfield="a"
	location_subfield="h"
	bib_mattype_field="380"
	taglabelmap="z:barcode a:call# q:call#suffix s:call#suffix2 c:copy v:volume g:price d:volume_dates p:part h:location x:enum i:staff_note"
fi

if [[ ${system} == "opals" ]];then
	identifier="001"
	item_field="852p"
	item_call_subfield="h"
	location_subfield="b"
	taglabelmap="p:barcode k:call#prefix h:call# i:call# m:call#suffix v:volume t:copy 3:mattype 9:price"
fi

if [[ ${system}  == "sierra"  ]];then
	bib_call_field="090"
	identifier="907a"
	item_field="945l"
	item_call_subfield="a"
	location_subfield="l"

	taglabelmap="y:record#item i:barcode l:location o:icode2 t:itype s:status a:call_marc b:call_nonmarc c:volume g:copy j:agency m:msg q:imsg r:opacmsg n:note u:totchk v:totrenwl w:ytdcirc z:created"
fi

if [[ ${system}  == "sirsi"  ]];then
	bib_call_field="090"
	bib_call_fallback="050"
	identifier="997a"
	item_field="999i"
	item_call_subfield="a"
	location_subfield="m"

	taglabelmap="i:barcode  D:location G:temp_location X:itype t:mattype 3:volume x:imsg z:opacmsg o:staff_note p:public_note q:checkin_note G:temp_location s:status r:checkout_note e:accession 0:volume n:totalCharges u:acqDate x:itemCat1 z:itemCat2"

fi

if [[ ${system}  == "softlink"  ]];then
	identifier="907a"
	item_field="995a"
	item_call_subfield="k"
	location_subfield="a"
	taglabelmap="a:location j:call y:barcode Z:itype h:copy e:accession u:status J:note"
fi

if [[ ${system} == "tinycat" ]];then
	identifier="001"
	item_field="991b"
	item_call_subfield="h"
	location_subfield="b"
	bib_call_field="090"
	bib_call_fallback="050"
	taglabelmap="b:location h:call# p:barcode"
fi

if [[ ${system} == "tlc" ]];then
	identifier="001"
	item_field="949g"
	item_call_subfield="j"
	location_subfield="D"
	bib_call_field="090"
	bib_call_fallback="050"
	bib_mattype_field="380"
	taglabelmap="a:location c:call# g:barcode n:copy p:price i:volume j:enumeration k:enumeration_2 q:staff_note 7:staff_note2 5:status x:fund"
fi

if [[ ${system} == "virtua" ]];then
	special[1]="949" # field "s" is a special function, disable if not used for status
	identifier="001"
	item_field="949D"
	item_call_subfield="a"
	location_subfield="D"
	bib_call_field="090"
	bib_call_fallback="050"

	taglabelmap="a:call# b:call#cutter 6:barcode F:copy D:location X:itype o:staff_note p:public_note q:checkin_note G:temp_location s:status r:checkout_note e:accession 0:volume"
fi

if [[ ${system} == "wms"  ]];then
	identifier="004"
	item_field="876p"
	item_call_subfield=""
	location_subfield=""
	taglabelmap="p:barcode 3:volume x:imsg z:opacmsg"
fi

speciallist="$(echo ${special[@]})"

echo "Evaluating file. Please wait."

read -r -d '' awkscript << "ENDOFAWK"
#!/usr/bin/awk -f 

BEGIN { records_found = 0 
	num_tags = split(TAGLABELMAP, pairs, " ")

	for (i = 1; i <= num_tags; i++) {
		split(pairs[i], kv, ":")
		tags[i] = kv[1]
		tag_index[tags[i]] = i
		labels[i] = kv[2]
	}

	subfield_regex=SFS"."

	virtua_status_match = "("SFS"s[0-9]+):[0-9;:]+"

	split(SPECIALLIST, special, " ")

	required_item_subfield = substr(ITEMFIELD, 4, 1)
	ITEMFIELD = substr(ITEMFIELD, 1, 3)
}

function destiny_852() { 
	# material type
	sub("@a", SFS"u", field_content)
	vol_subfield=""

	# cat date
	sub("@c", SFS"r", field_content)

	# collection 
	sub("@f", SFS"f", field_content)

	# remap first $x to item note $n 
	sub(SFS"x", SFS"n", field_content)

	# volume info is in @j@j@j@i@i@i with label in j
	# and enum in @i. Pair things up and string it together

	match(field_content, "@j[^"SFS"]*", val)
	split(val[0], volume_info, "@")

	for (i in volume_info) {
		sub(/^[ij]/, "", volume_info[i])
	}
	vol_subfield = volume_info[2]" "volume_info[5]" "volume_info[3]" "volume_info[6]" "volume_info[4]" "volume_info[7]
	sub(" *$", "", vol_subfield)
	field_content = field_content""SFS"j"vol_subfield

	# pitch all subfield b's
	sub("@b", SFS"8", field_content)

	# pitch all remaining @fields
	gsub("@[^"SFS"]*", "", field_content)
}

function virtua_949() { 
	# status 
	field_content = gensub(virtua_status_match, "\\\1", "g", field_content)
}

function extract_subfields() { 
	real_item = 0
	for (j=1;j<=num_tags;j++) { item_subfield[j] = "" }

	split(field_content, subfields, SFS)
	
	for (subfield=1;subfield<=length(subfields);subfield++) {
		extracted_tag=substr(subfields[subfield], 1, 1)
		index_position=tag_index[extracted_tag]

		if (index_position > 0) {
		if (substr(subfields[subfield], 1, 1) == extracted_tag) {
			if (extracted_tag == required_item_subfield) {real_item = 1}
			if (item_subfield[index_position] == "") {
				item_subfield[index_position] = substr(subfields[subfield],2)
				gsub(/^[ \\-]*$/, "", item_subfield[index_position])
			} else { 
				item_subfield[index_position] = item_subfield[index_position]";"substr(subfields[subfield],2) 
			}

			gsub(/^ *+| +$/, "", item_subfield[index_position])

			if (tags[index_position] == LOCATION) { location = item_subfield[index_position] }
			if (tags[index_position] == CALL_PREFIX) { callprefix = item_subfield[index_position] }
			if (tags[index_position] == CALL) { callnum = item_subfield[index_position] }
			if (tags[index_position] == CALL_SUFFIX) { callsuffix = item_subfield[index_position] }
		}	
	}
	}

	if (IDENTIFIER == "004") {
		holdid = tag001 
		gsub(/[^a-zA-Z0-9]/, "", bibno)
   	} else {
      		if (length(callnum) > 1) {
         		holdid =  bibno""location""callprefix""callnum""callsuffix
      		} else {
         		holdid =  bibno""location""bib_call
      		}
   	}

	gsub(/[^a-zA-Z0-9]/, "", holdid)

	lineout = tag001"\t"bibno"\t"holdid"\t"bib_call"\t"holdings_type"\t"bib_mattype

	for (j=1;j<=num_tags;j++) {
		lineout = lineout"\t"item_subfield[j]
	}
	
	if (bibno != "" && real_item == 1) { print lineout >> OUTFILE;numItems++ }
	lineout = ""
}

function extract_identifiers() {

	tag001=tag004=bib_subtype=bibno=bib_call=holdid=callnum=location=""
	tagid = substr(IDENTIFIER, 4, 1)

	for (i=1; i<=directory_length; i=i+12) {
		if (substr(directory, i, 3) == "001") {

			field_length = substr(directory, i + 3, 4) + 0
			starting_pos = substr(directory, i + 7, 5) 

			tag001 = substr(record_content, starting_pos, field_length)
			gsub(/^ *+| +$/, "", tag001)
			gsub(FS, "", tag001)
		}
		if (substr(directory, i, 3) == "004") {

			field_length = substr(directory, i + 3, 4) + 0
			starting_pos = substr(directory, i + 7, 5) 

			tag004 = substr(record_content, starting_pos, field_length - 1)
			gsub(/^ *+| +$/, "", tag004)
		}

		if (bibno == "") {
			if (substr(directory, i, 3) == substr(IDENTIFIER, 1, 3)) {

				field_length = substr(directory, i + 3, 4) + 0
				starting_pos = substr(directory, i + 7, 5) 

				split(field_content, subfields, SFS)

				bibno = substr(record_content, starting_pos, field_length)
				split(bibno, subfields, SFS)
	
				for (subfield in subfields) {
					if (tagid == substr(subfields[subfield], 1, 1)) {
						bibno = substr(subfields[subfield],2)
					}	
				}
			#gsub(/^ *+| +$/, "", bibno)
			gsub(/[^\.a-zA-Z0-9]/, "", bibno)
			}
		}
	}
}

function extract_items() {
	for (d_iter=1; d_iter<=directory_length; d_iter=d_iter+12) {
		marc_tag = substr(directory, d_iter, 3)
		####
      if (marc_tag == BIB_CALL_FIELD) {

         field_length = substr(directory, d_iter + 3, 4) + 0
         starting_pos = substr(directory, d_iter + 7, 5)

         bib_call = substr(record_content, starting_pos + 5, field_length - 5)
         gsub(subfield_regex, " ", bib_call)
         }

      if (marc_tag == BIB_CALL_FALLBACK) {
			if (bib_call == "") {
         	field_length = substr(directory, d_iter + 3, 4) + 0
         	starting_pos = substr(directory, d_iter + 7, 5)

         	bib_call = substr(record_content, starting_pos + 5, field_length - 5)
         	gsub(subfield_regex, " ", bib_call)
				}
         }

      if (marc_tag == BIB_MATTYPE_FIELD) {

         field_length = substr(directory, d_iter + 3, 4) + 0
         starting_pos = substr(directory, d_iter + 7, 5)

         bib_mattype = substr(record_content, starting_pos + 5, field_length - 5)
         gsub(subfield_regex, " ", bib_mattype)
         }

		if (marc_tag == ITEMFIELD) {

			field_length = substr(directory, d_iter + 3, 4) + 0
			starting_pos = substr(directory, d_iter + 7, 5) 
			field_content = ""

			if (substr(record_content, starting_pos + 3, 1) == SFS) {
				field_content = substr(record_content, starting_pos + 3, field_length - 3)
			} else {
				field_content = substr(record_content, starting_pos + 1, field_length - 1)
			}

			for (special_iter in special) { 
				if (marc_tag == special[special_iter]) { 
					functionByVariable=SYSTEM"_"marc_tag

					@functionByVariable()		
				} 
			}

			extract_subfields()
		}
	}
}

{

leader=substr($0,1,24)
baseaddress=substr(leader,13, 5) + 0
directory=substr($0,25, baseaddress - 25)
directory_length=length(directory) 
directory_check=(directory_length % 12)
record_content=substr($0, baseaddress + 1)
bib_mattype=substr(leader, 7, 1)
holdings_type=substr(leader, 8, 1)

if (directory_check == 0) {
	if (NR == 1 && FILENAME == "tmp_marcitemextract-1.mrc") { 
		lineout = "tag001\tbib_no\tholdid\tbib_call\trectype\tbib_mattype"
		for (i=1;i<=num_tags;i++) {
			lineout = lineout"\t"labels[i]
		}
		print lineout > OUTFILE
		lineout = ""
	}
	extract_identifiers()
	extract_items()
}

if (NR % 1000 == 0 && FILENAME == "tmp_marcitemextract-4.mrc" ){ printf "Records processed: "NR*5"\r" }

}

ENDOFAWK

echo -e "${awkscript}" > tmp_itemextract
chmod 700 tmp_itemextract

numrecs=$(awk -v RS=$'\x1d' 'END{print NR}' "${infile}")
num_per_file=$(($numrecs / 5 + 1))

echo "Splitting into 5 files to speed processing"

echo "${numrecs} MARC records detecting. Splitting into 5 files to speed processing."

read -r -d '' awkscript << "ENDOFAWK"
#!/usr/bin/awk -f
#
BEGIN { 
	filecounter = 1
	counter = 1
	fname = "tmp_marcitemextract"
	}
{
	if (counter > NUMPERFILE) { 
		filecounter++
		counter = 1
	}

	tmpfile = sprintf("%s-%d.mrc", fname, filecounter)
	counter++
	print $0 > tmpfile
}
ENDOFAWK
echo -e "${awkscript}" > tmp_counter
chmod 700 tmp_counter

awk -v RS=$'\x1d' -v ORS=$'\x1d' -v NUMRECS=${numrecs} -v NUMPERFILE=${num_per_file} -f tmp_counter "${infile}"

splitlist=(tmp_marcitemextract-1.mrc tmp_marcitemextract-2.mrc tmp_marcitemextract-3.mrc tmp_marcitemextract-4.mrc tmp_marcitemextract-5.mrc)

for splitfile in ${splitlist[@]};do
	tempout=${splitfile%????}.seq
	awk -v RS=$'\x1d' -v ORS="\n" -v SFS=$'\x1f' -v FS=$'\x1e' -v OFS="\t" -v IDENTIFIER="${identifier}" -v ITEMFIELD="${item_field}" -v CALL="${item_call_subfield}" -v CALL_PREFIX="${item_call_prefix}" -v CALL_SUFFIX="${item_call_suffix}" -v BIB_CALL_FIELD="${bib_call_field}" -v BIB_CALL_FALLBACK="${bib_call_fallback}" -v BIB_MATTYPE_FIELD="${bib_mattype_field}" -v LOCATION="${location_subfield}" -v TAGLABELMAP="${taglabelmap}" -v SPECIALLIST="${speciallist}" -v SYSTEM="${system}" -v OUTFILE="${tempout}" -b -f tmp_itemextract "${splitfile}" &
done
wait

cat tmp_marcitemextract*seq >> "${outfile}"
rm -f tmp_marcitemextract*

echo "${numrecs} MARC records have been processed. Item records have been sent to ${outfile}"
echo


rm -f tmp_itemextract* tmp_counter
